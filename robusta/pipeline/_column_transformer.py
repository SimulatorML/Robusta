from typing import List, Tuple, Optional

import pandas as pd
from sklearn.base import TransformerMixin, clone
from sklearn.pipeline import _name_estimators
from sklearn.utils.metaestimators import _BaseComposition

from robusta.preprocessing import Identity, ColumnSelector


class ColumnTransformer(_BaseComposition, TransformerMixin):
    """
    Applies transformers to columns of an array or pandas DataFrame.

    This estimator allows different columns or column subsets of the input
    to be transformed separately and the features generated by each transformer
    will be concatenated to form a single feature space. This is useful for
    combining several feature extraction mechanisms or transformations
    into a single transformer.

    Parameters
    ----------
    transformer_list : list
        List of (string, transformer, columns) tuples (implementing fit/transform).

    remainder : {'drop', 'pass'} or estimator, default 'drop'
        By default, only the specified columns in `transformer_list` are
        transformed and combined in the output, and the non-specified
        columns are dropped. (default of ``'drop'``).
        By specifying ``remainder='pass'``, all remaining columns that
        were not specified in `transformer_list` will be automatically passed
        through. This subset of columns is concatenated with the output of
        the transformers.
        By setting ``remainder`` to be an estimator, the remaining
        non-specified columns will use the ``remainder`` estimator. The
        estimator must support `fit` and `transform`.

    Attributes
    ----------
    transformers_ : list
        The collection of fitted transformers as tuples of (name, fitted_transformer,
        column). fitted_transformer can be an estimator, ‘drop’, or ‘pass’.
        In case there were no columns selected, this will be the unfitted transformer.

        If there are remaining columns, the final element is a tuple of the form:
        (‘remainder’, transformer, remaining_columns_) corresponding to the remainder
        parameter. If there are remaining columns, then
        len(transformers_)==len(transformers)+1, otherwise
        len(transformers_)==len(transformers).

    named_transformers_ : Bunch object, a dictionary with attribute access
        Access the fitted transformer by name.

    remaining_columns_ : list of strings
        List of remining columns.

    """

    def __init__(self, transformer_list: list, remainder: str = "drop"):
        self.remaining_columns_ = None
        self.named_transformers_ = None
        self.transformers_ = None
        self.transformer_list = transformer_list
        self.remainder = remainder

    @property
    def _transformers(self) -> list:
        """
        Internal list of transformer only containing the name and
        transformers, dropping the columns. This is for the implementation
        of get_params via BaseComposition._get_params which expects lists
        of tuples of len 2.

        Returns
        -------
        list:
            List of transformers
        """
        return [(name, trans) for name, trans, _ in self.transformer_list]

    def fit(
        self, X: pd.DataFrame, y: Optional[pd.Series] = None
    ) -> "ColumnTransformer":
        """
        Fit all transformers using X.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        y : array-like, shape (n_samples, ...), optional
            Targets for supervised learning.

        Returns
        -------
        self : ColumnTransformer
            This estimator

        """

        # initialize variables
        self.transformers_ = []
        self.named_transformers_ = {}
        self.remaining_columns_ = set(X.columns)

        # iterate over transformer list
        for name, transformer, cols in self.transformer_list:
            # Clone & fit
            fitted_transformer = clone(transformer).fit(X[cols], y)
            self.named_transformers_[name] = fitted_transformer
            # Access by key
            fitted_tuple = (name, fitted_transformer, cols)
            self.transformers_.append(fitted_tuple)
            # Remainin columns
            self.remaining_columns_ -= set(cols)

        # Store remaining columns that are not part of any transformer
        self.remaining_columns_ = list(self.remaining_columns_)

        # If there are remaining columns, transform them based on the given remainder value
        if self.remaining_columns_:
            name, cols = "remainder", self.remaining_columns_

            # Handle remainder based on given value
            if hasattr(self.remainder, "fit") and hasattr(self.remainder, "transform"):
                # If remainder is an estimator, clone & fit it
                fitted_transformer = clone(self.remainder).fit(X[cols], y)

            elif self.remainder is "pass":
                # If remainder is 'pass', do nothing
                fitted_transformer = Identity().fit(X[cols], y)

            elif self.remainder is "drop":
                # If remainder is 'drop', remove columns
                fitted_transformer = ColumnSelector(cols=[]).fit(X[cols], y)

            else:
                # If remainder is not 'pass', 'drop', or an estimator, raise error
                raise ValueError(
                    'Unknown type for remainder. Must be "drop", "pass" or estimator.'
                )

            # Create tuple to store fitted transformer, transformer name, and columns
            fitted_tuple = (name, fitted_transformer, cols)

            # Store fitted tuple in transformers_ list
            self.transformers_.append(fitted_tuple)

        # return self object
        return self

    def transform(self, X: pd.DataFrame) -> pd.DataFrame:
        """
        Transform X separately by each transformer, concatenate results.

        Parameters
        ----------
        X : DataFrame of shape [n_samples, n_features]
            Input data, of which specified subsets are used to fit the transformers.

        Returns
        -------
        Xt : DataFrame, shape (n_samples, sum_n_components)
            hstack of results of transformers. sum_n_components is the
            sum of n_components (output dimension) over transformers.
        """

        # Initialize list to store transformed outputs of each transformer
        Xt_list = []

        # iterate over transformers and transform input data X using each transformer
        for name, transformer, cols in self.transformers_:
            Xt_list.append(transformer.transform(X[cols]))

        # concatenate transformed outputs of all transformers into a single DataFrame
        Xt = pd.concat(Xt_list, axis=1)
        return Xt

    def get_params(self, deep: bool = True) -> dict:
        """
        Get parameters for this estimator.

        Parameters
        ----------
        deep : boolean, optional
            If True, will return the parameters for this estimator and
            contained subobjects that are estimators.
        Returns
        -------
        params : mapping of string to any
            Parameter names mapped to their values.

        """
        return self._get_params("_transformers", deep=deep)

    def set_params(self, **kwargs) -> "ColumnTransformer":
        """
        Set the parameters of this estimator.
        Valid parameter keys can be listed with ``get_params()``.

        Returns
        -------
        self:
            ColumnTransformer

        """
        self._set_params("_transformers", **kwargs)
        return self


def _get_transformer_list(
    estimators: List[Tuple],
) -> List[Tuple[str, object, List[str]]]:
    """
    Constructs a list of (name, transformer, column) tuples from a list of (transformer, column) tuples.

    Parameters
    ----------
    estimators : list
        A list of (transformer, column) tuples.

    Returns
    -------
    transformer_list : list
        A list of (name, transformer, column) tuples.
    """

    # Unzip the list of (transformer, column) tuples into two separate lists
    transformers, columns = zip(*estimators)

    # Get the names of the transformers using the _name_estimators() utility function
    names, _ = zip(*_name_estimators(transformers))

    # Combine the names, transformers, and columns into a list of tuples
    transformer_list = list(zip(names, transformers, columns))

    return transformer_list


def make_column_transformer(*transformers, **kwargs) -> ColumnTransformer:
    """
    Construct a ColumnTransformer from the given transformers.

    This is a shorthand for the ColumnTransformer constructor; it does not
    require, and does not permit, naming the transformers. Instead, they will
    be given names automatically based on their types. It also does not allow
    weighting with ``transformer_weights``.

    Parameters
    ----------
    *transformers :
        tuples of transformers and column selections

    **kwargs
        Additional params

    Returns
    -------
    ct :
        ColumnTransformer

    """
    # transformer_weights keyword is not passed through because the user
    # would need to know the automatically generated names of the transformers
    n_jobs = kwargs.pop("n_jobs", None)
    remainder = kwargs.pop("remainder", "drop")
    sparse_threshold = kwargs.pop("sparse_threshold", 0.3)

    if kwargs:
        raise TypeError(
            'Unknown keyword arguments: "{}"'.format(list(kwargs.keys())[0])
        )

    transformer_list = _get_transformer_list(transformers)

    return ColumnTransformer(transformer_list, remainder=remainder)
